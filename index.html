<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Platformer — Mobile Touch Ready</title>
<style>
  :root{--bg:#071228;--fg:#e7f0ff;--accent:#4fa3ff}
  html,body{height:100%;margin:0;font-family:system-ui,Arial;background:linear-gradient(#071228,#081629);color:var(--fg)}
  #wrap{display:flex;justify-content:center;padding:12px}
  canvas{background:#081427;border-radius:10px;box-shadow:0 12px 40px rgba(0,0,0,.6);max-width:100%;height:auto}
  .hud {position:fixed;left:12px;top:12px;z-index:60}
  .hud .line{font-weight:700;margin-bottom:6px}
  .top-right {position:fixed;right:12px;top:12px;z-index:60;display:flex;gap:8px}
  .btn {background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.06);padding:8px 10px;border-radius:10px;color:var(--fg);font-weight:700;cursor:pointer}
  /* touch controls */
  .touch-wrap {position:fixed;left:10px;bottom:10px;z-index:70;display:none;gap:12px;align-items:center}
  .dpad{display:flex;gap:8px;align-items:center}
  .touch-btn{width:72px;height:72px;border-radius:12px;background:rgba(255,255,255,.04);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:26px;user-select:none;touch-action:none}
  .jump-btn{width:96px;height:96px;border-radius:16px;background:linear-gradient(180deg,#3b82f6,#1e40af);color:white;display:flex;align-items:center;justify-content:center;font-weight:900;user-select:none;touch-action:none}
  .legend{font-size:13px;color:#9fb7d9;margin-top:6px}
  @media (max-width:780px){ .touch-wrap {display:flex} .top-right{display:none} }
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="screen" width="960" height="540"></canvas>
  </div>

  <div class="hud">
    <div class="line">Score: <span id="score">0</span></div>
    <div class="line">Lives: <span id="lives">3</span></div>
    <div class="legend">Arrows/WASD or use on-screen buttons (mobile)</div>
  </div>

  <div class="top-right">
    <button id="pauseBtn" class="btn">Pause (P)</button>
    <button id="restartBtn" class="btn">Restart</button>
  </div>

  <!-- On-screen touch controls (shown on small screens) -->
  <div class="touch-wrap" id="touchWrap" aria-hidden="true">
    <div class="dpad">
      <div id="leftBtn" class="touch-btn" title="Left">◀</div>
      <div id="rightBtn" class="touch-btn" title="Right">▶</div>
    </div>
    <div style="width:12px"></div>
    <div id="jumpBtn" class="jump-btn" title="Jump">JUMP</div>
  </div>

<script>
/* --------- Basic platformer with mobile touch controls --------- */

/* CONFIG */
const CONFIG = {
  tileSize: 48,
  gravity: 1400,
  moveSpeed: 260,
  jumpSpeed: 640,
  canvasW: 960,
  canvasH: 540,
  startLives: 3,
  coinValue: 10
};

/* Simple level (small) */
const LEVEL = [
  "................................................",
  "................................................",
  "................................................",
  "................................................",
  ".....C......C......C..................C........",
  "...........#######..................###........",
  "..P...........................................G",
  "###############.....###########################",
  "################################################"
];

/* ---- util ---- */
const now = () => performance.now()/1000;
const clamp = (v,a,b) => Math.max(a,Math.min(b,v));

/* ---- canvas ---- */
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');
canvas.width = CONFIG.canvasW; canvas.height = CONFIG.canvasH;

/* ---- UI refs ---- */
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');

/* ---- touch state ---- */
let touchState = { left:false, right:false, jump:false };
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const jumpBtn = document.getElementById('jumpBtn');
const touchWrap = document.getElementById('touchWrap');

/* Pointer/touch helper to support mouse & touch */
function bindPress(el, onDown, onUp){
  if(!el) return;
  // pointer events for modern browsers
  el.addEventListener('pointerdown', e => { e.preventDefault(); onDown(); }, {passive:false});
  document.addEventListener('pointerup', e => { onUp(); }, {passive:true});
  // fallback for touch-only older devices
  el.addEventListener('touchstart', e => { e.preventDefault(); onDown(); }, {passive:false});
  document.addEventListener('touchend', e => { onUp(); }, {passive:true});
  // allow click for desktops
  el.addEventListener('mousedown', e => { e.preventDefault(); onDown(); });
  document.addEventListener('mouseup', e => { onUp(); });
}

/* attach */
bindPress(leftBtn,  ()=> touchState.left = true,  ()=> touchState.left = false);
bindPress(rightBtn, ()=> touchState.right = true, ()=> touchState.right = false);
bindPress(jumpBtn,  ()=> touchState.jump = true,  ()=> touchState.jump = false);

/* ---- keyboard ---- */
let keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; if(e.key==='p' || e.key==='P') togglePause(); if(e.key==='r' || e.key==='R') restart(); });
window.addEventListener('keyup', e => { keys[e.key] = false; });

/* ---- level build ---- */
let tiles = LEVEL.map(r => r.split(''));
const rows = tiles.length, cols = tiles[0].length;
let coins = [], goal = null, player = null;

function build(){
  coins = [];
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const ch = tiles[y][x];
      const px = x*CONFIG.tileSize, py = y*CONFIG.tileSize;
      if(ch === 'P'){
        player = { x: px + 6, y: py + 6, w:34, h:44, vx:0, vy:0, onGround:false, canDouble:true, lives: CONFIG.startLives };
        tiles[y][x] = '.';
      }
      if(ch === 'C'){
        coins.push({x: px + CONFIG.tileSize/4, y: py + CONFIG.tileSize/4, w: CONFIG.tileSize/2, h: CONFIG.tileSize/2, taken:false});
        tiles[y][x] = '.';
      }
      if(ch === 'G'){
        goal = {x:px, y:py, w:CONFIG.tileSize, h:CONFIG.tileSize};
        tiles[y][x] = '.';
      }
    }
  }
  if(!player) player = {x:80,y:80,w:34,h:44,vx:0,vy:0,onGround:false,canDouble:true,lives:CONFIG.startLives};
}

build();

/* ---- game state ---- */
let score = 0;
let paused = false;
let lastTime = now();
let camera = {x:0,y:0};

/* ---- collision helpers ---- */
function rectOverlap(a,b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}
function tileAt(px,py){
  const tx = Math.floor(px / CONFIG.tileSize), ty = Math.floor(py / CONFIG.tileSize);
  if(ty < 0 || tx < 0 || ty >= rows || tx >= cols) return '#';
  return tiles[ty][tx];
}
function isSolid(px,py){
  const tx = Math.floor(px / CONFIG.tileSize), ty = Math.floor(py / CONFIG.tileSize);
  if(ty < 0 || tx < 0 || ty >= rows || tx >= cols) return true;
  return tiles[ty][tx] === '#';
}

/* ---- physics move (simple AABB) ---- */
function moveEntity(e, dt){
  // horizontal
  e.x += e.vx * dt;
  if(e.vx !== 0){
    const dir = e.vx > 0 ? 1 : -1;
    const probeX = dir > 0 ? e.x + e.w : e.x;
    for(let y = Math.floor(e.y/CONFIG.tileSize); y <= Math.floor((e.y+e.h-1)/CONFIG.tileSize); y++){
      const tx = Math.floor(probeX / CONFIG.tileSize);
      if(y < 0 || tx < 0 || y >= rows || tx >= cols) continue;
      if(tiles[y][tx] === '#'){
        if(dir > 0) e.x = tx*CONFIG.tileSize - e.w - 0.01;
        else e.x = (tx+1)*CONFIG.tileSize + 0.01;
        e.vx = 0;
      }
    }
  }
  // vertical
  e.y += e.vy * dt;
  if(e.vy !== 0){
    const dirY = e.vy > 0 ? 1 : -1;
    const probeY = dirY > 0 ? e.y + e.h : e.y;
    for(let x = Math.floor(e.x/CONFIG.tileSize); x <= Math.floor((e.x+e.w-1)/CONFIG.tileSize); x++){
      const ty = Math.floor(probeY / CONFIG.tileSize);
      if(ty < 0 || x < 0 || ty >= rows || x >= cols) continue;
      if(tiles[ty][x] === '#'){
        if(dirY > 0){
          e.y = ty*CONFIG.tileSize - e.h - 0.01;
          e.vy = 0;
          e.onGround = true;
        } else {
          e.y = (ty+1)*CONFIG.tileSize + 0.01;
          e.vy = 0;
        }
      }
    }
  }
}

/* ---- input & update ---- */
function attemptJump(){
  if(player.onGround){
    player.vy = -CONFIG.jumpSpeed;
    player.onGround = false;
    player.canDouble = true;
  } else if(player.canDouble){
    player.vy = -CONFIG.jumpSpeed * 0.9;
    player.canDouble = false;
  }
}

function update(dt){
  if(paused) return;

  // read input (keyboard and touch)
  let desired = 0;
  if(keys['ArrowLeft'] || keys['a'] || keys['A'] || touchState.left) desired -= 1;
  if(keys['ArrowRight'] || keys['d'] || keys['D'] || touchState.right) desired += 1;

  const targetVx = desired * CONFIG.moveSpeed;
  const dv = targetVx - player.vx;
  const accel = 4200 * dt;
  player.vx += clamp(dv, -accel, accel);

  if(desired === 0 && player.onGround) player.vx *= 0.8;
  // gravity
  player.vy += CONFIG.gravity * dt;
  player.vy = clamp(player.vy, -1200, 1200);

  // jump controls (only on press)
  const jumpPressed = keys[' '] || keys['k'] || keys['K'] || touchState.jump;
  if(jumpPressed && !keys['_jumpHandled']){
    keys['_jumpHandled'] = true;
    attemptJump();
  }
  if(!(keys[' '] || keys['k'] || keys['K'] || touchState.jump)) keys['_jumpHandled'] = false;

  // reset onGround then move
  player.onGround = false;
  moveEntity(player, dt);

  // coins
  for(const c of coins){
    if(!c.taken && rectOverlap(player, c)){
      c.taken = true; score += CONFIG.coinValue;
      scoreEl.innerText = score;
    }
  }

  // goal
  if(goal && rectOverlap(player, goal)){
    // simple win: restart level
    showTemp("Level Complete!");
    setTimeout(() => resetLevel(), 800);
  }

  // camera follow
  const targetX = player.x + player.w/2 - canvas.width/2;
  const targetY = player.y + player.h/2 - canvas.height/2;
  camera.x += (targetX - camera.x) * 0.12;
  camera.y += (targetY - camera.y) * 0.12;
  // clamp
  camera.x = clamp(camera.x, 0, Math.max(0, cols*CONFIG.tileSize - canvas.width));
  camera.y = clamp(camera.y, 0, Math.max(0, rows*CONFIG.tileSize - canvas.height));
}

/* ---- draw ---- */
function draw(){
  ctx.clearRect(0,0,canvas.width, canvas.height);
  // background
  ctx.fillStyle = "#071228";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // tiles
  const startCol = Math.floor(camera.x / CONFIG.tileSize);
  const endCol = Math.ceil((camera.x + canvas.width) / CONFIG.tileSize);
  const startRow = Math.floor(camera.y / CONFIG.tileSize);
  const endRow = Math.ceil((camera.y + canvas.height) / CONFIG.tileSize);

  for(let y = startRow; y < endRow; y++){
    if(y < 0 || y >= rows) continue;
    for(let x = startCol; x < endCol; x++){
      if(x < 0 || x >= cols) continue;
      const ch = tiles[y][x];
      const sx = x*CONFIG.tileSize - camera.x;
      const sy = y*CONFIG.tileSize - camera.y;
      if(ch === '#'){
        ctx.fillStyle = '#15314a';
        roundRect(ctx, sx, sy, CONFIG.tileSize, CONFIG.tileSize, 6, true, false);
      }
    }
  }

  // coins
  for(const c of coins){
    if(c.taken) continue;
    const sx = c.x - camera.x, sy = c.y - camera.y;
    ctx.beginPath();
    ctx.ellipse(sx + c.w/2, sy + c.h/2, c.w/2, c.h/2, 0, 0, Math.PI*2);
    ctx.fillStyle = '#ffdf5a'; ctx.fill(); ctx.strokeStyle = '#f0b63a'; ctx.stroke();
  }

  // goal
  if(goal){
    const sx = goal.x - camera.x, sy = goal.y - camera.y;
    ctx.fillStyle = '#5af7a3'; ctx.fillRect(sx+8, sy+8, goal.w-16, goal.h-16);
    ctx.fillStyle = '#072d1a'; ctx.fillText('GO', sx + goal.w/2 - 8, sy + goal.h/2 + 6);
  }

  // player
  const px = player.x - camera.x, py = player.y - camera.y;
  ctx.fillStyle = '#4fa3ff';
  roundRect(ctx, px, py, player.w, player.h, 8, true, false);

  // HUD values already updated in DOM
}

/* ---- helpers ---- */
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if(typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
  ctx.beginPath();
  ctx.moveTo(x + r.tl, y);
  ctx.lineTo(x + w - r.tr, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
  ctx.lineTo(x + w, y + h - r.br);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
  ctx.lineTo(x + r.bl, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
  ctx.lineTo(x, y + r.tl);
  ctx.quadraticCurveTo(x, y, x + r.tl, y);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke){ ctx.strokeStyle = stroke; ctx.stroke(); }
}

/* ---- game control ---- */
function resetLevel(){
  // rebuild level and player position
  tiles = LEVEL.map(r => r.split(''));
  build();
  score = 0; scoreEl.innerText = score;
  camera.x = camera.y = 0;
}
function restart(){
  resetLevel();
  paused = false;
}
function togglePause(){
  paused = !paused;
  showTemp(paused ? "Paused" : "Resumed");
}

/* small temporary message */
function showTemp(t){
  const prev = document.title;
  document.title = t;
  setTimeout(()=> document.title = prev, 800);
}

/* ---- main loop ---- */
let last = now();
function loop(){
  const t = now();
  let dt = t - last; if(dt > 0.04) dt = 0.04;
  last = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* init */
pauseBtn.onclick = togglePause;
restartBtn.onclick = restart;

/* show touch on small screens */
if(window.innerWidth <= 780) {
  touchWrap.style.display = 'flex';
  touchWrap.setAttribute('aria-hidden','false');
}

resetLevel();
last = now();
loop();

</script>
</body>
</html>


